#!/bin/bash

PATH=/bin:/usr/bin:/sbin:/usr/sbin

add_bin() {
	binpath=$(type -p $1)
	[ "$binpath" ] || return
	binlib=$(ldd $binpath | grep -v "not" | sed "s/\t//" | cut -d " " -f1)
	
	[ -f "$binpath" ] || msgwarn "missing binary: $1"
	if [ -L $binpath ]; then
		add_file $(type -p $(basename $(readlink $binpath)))
	fi
	add_file $binpath
	
	for lib in $binlib; do
		case $lib in
			linux-vdso.so.1|linux-gate.so.1) continue ;;
		esac
		lib=$(PATH=/lib:/lib64:/usr/lib:/usr/lib64 type -p $lib)
		if [ "$lib" ] && [ ! -e $WDIR/lib/$(basename $lib) ]; then
			add_file $lib
		fi
		unset lib
	done
	unset binpath binlib
	shift
	if [ "$1" ]; then
		add_bin $@
	fi
}

add_module() {
	[ "$1" ] || return
	if modinfo $1 &>/dev/null; then
		modname=$(modinfo -F name $1)
		modpath=$(modinfo -F filename $1)
	else
		msgwarn "missing module: $1"
		return
	fi
	mkdir -p $WDIR/lib/modules/$KERNEL_VERSION/kernel
	cp $modpath $WDIR/lib/modules/$KERNEL_VERSION/kernel
	modinfo -F depends -k $KERNEL_VERSION $modname | while IFS=',' read -r -a line; do
		add_module ${line[@]}
	done
	unset modname modpath
	shift
	if [ "$1" ]; then
		add_module $@
	fi
}

add_allmodules() {
	if [ "$MINIMAL" = 1 ]; then
		automods
	else
		hugemods
		add_module $extra_modules
	fi	
	add_module ${MODULES[@]}
}

finalize_modules() {	
	cp /lib/modules/$KERNEL_VERSION/modules.* $WDIR/lib/modules/$KERNEL_VERSION
	awk -F'/' '{ print "kernel/" $NF }' /lib/modules/$KERNEL_VERSION/modules.order > $WDIR/lib/modules/$KERNEL_VERSION/modules.order
	depmod -b $WDIR $KERNEL_VERSION
}

add_file() {
	if [ "$1" ] && [ -f "$1" ]; then
		cp --parent $1 $WDIR
	fi
	shift
	if [ "$1" ]; then
		add_file $@
	fi
}

add_firmware() {
	local mod
	for mod in $(find $WDIR/lib/modules/$KERNEL_VERSION/kernel/ -type f -name "*.ko*"); do
		mod=$(basename $mod)
		modinfo -b $WDIR -k $KERNEL_VERSION ${mod%.ko*} -F firmware | while read -r line; do
			[ -f /lib/firmware/$line ] || msgwarn "missing firmware: $line"
			add_file /lib/firmware/$line
		done
	done
}

automods() {
	local mod
	for mod in $(lsmod | awk 'NF==3{print $1}{}'); do
		add_module $mod
	done
}

hugemods() {
	local modules mod
	for mod in $HUGEMODULES; do
		FTGT="$FTGT /lib/modules/$KERNEL_VERSION/$mod"
	done
	for modules in $(find $FTGT -type f -name "*.ko*" 2> /dev/null); do
		modules=$(echo ${modules%*.ko*})
		add_module $(basename $modules)
	done
}

run_build_hook() {
	local hook build_hook
	for hook in $(find /etc/mkinitramfs.d/ -name "*.hook"); do
		source $hook
		[ "$(type -t build_hook)" = "function" ] && build_hook &>/dev/null
	done
}

make_dirs() {
	mkdir -p $WDIR/{bin,dev,lib/firmware,run,sys,proc,usr}
	mkdir -p $WDIR/etc/{modprobe.d,udev/rules.d}
	ln -s lib $WDIR/lib64
	ln -s ../bin $WDIR/usr/bin
	ln -s bin $WDIR/sbin
	ln -s ../bin $WDIR/usr/sbin

	mknod -m 640 $WDIR/dev/console c 5 1
	mknod -m 664 $WDIR/dev/null    c 1 3
}

msg() {
	[ $QUIET ] && return
	echo ":: $@"
}

msgerr() {
	[ $QUIET ] && return
	echo "ERROR: $@"
}

msgwarn() {
	[ $QUIET ] && return
	echo "WARNING: $@"
}

cleanup() {
	rm -fr $WDIR
}

interrupted() {
	cleanup
	exit 1
}

usage() {	
	cat << EOF
Usage:
  $(basename $0) <option> <argument>
  
Options:
  -k <version>  custom kernel version
  -o <output>   custom output name
  -i <init>     custom init file
  -m            create minimal initramfs
  -q            quiet mode
  -h            print this help msg
	
EOF
}

parse_opt() {
	while [ $1 ]; do
		case $1 in
			-k)	if [ -z $2 ]; then
					echo "argument is needed for this option"
					exit 1
				fi
				KERNEL=$2
				shift 1 ;;
			-o)	if [ -z $2 ]; then
					echo "argument is needed for this option"
					exit 1
				fi
				OUTPUT=$2
				shift 1 ;;
			-i)	if [ -z $2 ]; then
					echo "argument is needed for this option"
					exit 1
				fi
				INIT=$2
				shift 1 ;;
			-c)	if [ -z $2 ]; then
					echo "argument is needed for this option"
					exit 1
				fi
				CUSTCONFIG=$2
				shift 1 ;;
			-m) MINIMAL=1 ;;
			-q)	QUIET=1 ;;
			-h)	usage; exit 0 ;;
			*)	echo "ERROR: invalid option '$1'"
				exit 1 ;;
		esac
		shift
	done
}

main() {
	parse_opt $@

	if [ "$UID" != "0" ]; then
		msgerr "need root access!"
		exit 1
	fi
	
	if [ ! $(type -p bsdcpio) ]; then
		msgerr "'bsdcpio' not found, please install 'libarchive' package."
		exit 1
	fi
	
	if [ -f "$CONFIG" ]; then
		. "$CONFIG"
	fi
	
	if [ "$CUSTCONFIG" ]; then
		if [ -f "$CUSTCONFIG" ]; then
			. $CUSTCONFIG
		else
			msgerr "config file '$CUSTCONFIG' not exist."
			exit 1
		fi
	fi
	
	if [ "$KERNEL" ]; then
		if [ -d /lib/modules/"$KERNEL" ]; then
			KERNEL_VERSION="$KERNEL"
		else
			msgerr "kernel directory '/lib/modules/$KERNEL' not exist."
			exit 1
		fi
	else
		if [ ! -d /lib/modules/"$KERNEL_VERSION" ]; then
			NOKMOD=1
		fi
	fi
	
	if [ "$INIT" ]; then
		if [ -f "$INIT" ]; then
			INITIN="$INIT"
		else
			msgerr "init file '$INIT' not exist."
			exit 1
		fi
	fi
	
	if [ "$OUTPUT" ]; then
		if [ $(basename $OUTPUT) != "$OUTPUT" ] && [ ! -d $(dirname $OUTPUT) ]; then
			msgerr "directory '$(dirname $OUTPUT)' for output '$(basename $OUTPUT)' not exist."
			exit 1
		fi
		INITRAMFS="$OUTPUT"
	fi

	[ $QUIET ] || echo "Generating initramfs..."
	
	msg "creating directories..."
	make_dirs

	msg "copying init..."
	install -m0755 $INITIN $WDIR/init
	
	msg "copying stuffs..."
	add_file /usr/share/terminfo/l/linux $UDEV_FILES ${FILES[@]}

	msg "copying binaries..."
	if [ "$MINIMAL" = 1 ]; then
		add_bin $MINIMALBIN
	else
		add_bin $HUGEBIN
	fi
	
	add_bin ${BINARIES[@]}
	
	msg "copying modules..."
	add_allmodules
	
	if [ -d /etc/mkinitramfs.d/ ]; then
		msg "running build_hook..."
		run_build_hook
	fi
	
	finalize_modules
	
	if [ -d $WDIR/lib/modules/$KERNEL_VERSION/kernel ]; then
		msg "copying firmwares..."
		add_firmware
	fi

	msg "generating initramfs..."
	rm -f "$INITRAMFS"
	( cd $WDIR ; find . | LANG=C bsdcpio -o -H newc --quiet | gzip -9 ) > $INITRAMFS

	cleanup
	[ $QUIET ] || echo "Generating initramfs done: $INITRAMFS ($(du -h $INITRAMFS | awk '{print $1}'))"
	
	exit 0
}

trap "interrupted" SIGHUP SIGINT SIGQUIT SIGTERM

binaries="sh cat cp killall ls mkdir mount find xargs grep fgrep"
binaries="$binaries umount sed sleep ln rm uname chroot chmod"
binaries="$binaries readlink basename modprobe blkid switch_root"
binaries="$binaries udevd udevadm kmod lsmod insmod setsid"

HUGEBIN="$binaries"
MINIMALBIN="sh mount kmod lsmod insmod udevd udevadm switch_root mkdir killall modprobe setsid"

# extra modules for livecd
extra_modules="cdrom mmc_core rtsx_pci rtsx_pci_sdmmc rtsx_pci_ms mmc_block ssb lpc_ich sdhci-acpi sdhci-pltfm sdhci sdhci-pci"

WDIR="/tmp/mkinitramfs.$$"
KERNEL_VERSION="$(uname -r)"
INITIN="/usr/share/mkinitramfs/init.in"
INITRAMFS="initrd-$KERNEL_VERSION.img"
CONFIG="/etc/mkinitramfs.conf"
UDEV_FILES="/etc/udev/udev.conf
            /lib/udev/ata_id
            /lib/udev/cdrom_id
            /lib/udev/scsi_id
            /lib/udev/rules.d/50-udev-default.rules
            /lib/udev/rules.d/60-cdrom_id.
            /lib/udev/rules.d/60-persistent-storage.rules
            /lib/udev/rules.d/64-btrfs.rules
            /lib/udev/rules.d/80-drivers.rules"
HUGEMODULES="kernel/crypto
             kernel/fs
             kernel/drivers/block
             kernel/drivers/ata
             kernel/drivers/input
             kernel/drivers/scsi
             kernel/drivers/hid
             kernel/drivers/usb/host
             kernel/drivers/usb/storage"

main $@
