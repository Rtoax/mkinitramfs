#!/bin/bash

PATH=/bin:/usr/bin:/sbin:/usr/sbin

add_binary() {
	local binpath binlib
	binpath=$(type -p $1)
	if [ -z "$binpath" ]; then
		msgwarn "missing binary: $1"
		return
	fi
	binlib=$(ldd $binpath | grep -v "not" | sed "s/\t//" | cut -d " " -f1)
	
	[ -f "$binpath" ] || msgwarn "missing binary: $1"
	if [ -L $binpath ]; then
		add_file $(type -p $(basename $(readlink $binpath)))
	fi
	add_file $binpath
	
	for lib in $binlib; do
		case $lib in
			linux-vdso.so.1|linux-gate.so.1) continue ;;
		esac
		lib=$(PATH=/lib:/lib64:/usr/lib:/usr/lib64 type -p $lib)
		if [ "$lib" ] && [ ! -e $INITDIR/lib/$(basename $lib) ]; then
			add_file $lib
		fi
		unset lib
	done
}

add_module() {
	local modname modpath
	[ "$1" ] || return
	if modinfo $1 &>/dev/null; then
		modname=$(modinfo -F name $1)
		modpath=$(modinfo -F filename $1)
	else
		msg "missing module: $1"
		return
	fi
	mkdir -p $INITDIR/lib/modules/$KERNEL_VERSION/kernel
	cp $modpath $INITDIR/lib/modules/$KERNEL_VERSION/kernel
	modinfo -F firmware -k $KERNEL_VERSION $modname | while read -r line; do
		if [ ! -f /lib/firmware/$line ]; then
			msgwarn "missing firmware for $modname: $line"
		else
			add_file /lib/firmware/$line
		fi
	done
	modinfo -F depends -k $KERNEL_VERSION $modname | while IFS=',' read -r -a line; do
		for l in ${line[@]}; do
			add_module "$l"
		done
	done
}

add_file() {
	if [ "$1" ] && [ -f "$1" ]; then
		cp --parent $1 $INITDIR
	else
		msgwarn "missing file: $1"
	fi
}

finalize_modules() {
	[ -d $INITDIR/lib/modules/$KERNEL_VERSION/kernel ] || return
	cp /lib/modules/$KERNEL_VERSION/modules.* $INITDIR/lib/modules/$KERNEL_VERSION
	awk -F'/' '{ print "kernel/" $NF }' /lib/modules/$KERNEL_VERSION/modules.order > $INITDIR/lib/modules/$KERNEL_VERSION/modules.order
	depmod -b $INITDIR $KERNEL_VERSION
}

run_build_hook() {
	if [ ! -d "$HOOKDIRS" ] && [ ! -d "$HOOKDIRSDATA" ]; then
		return
	fi
	if [ "${#HOOKS[@]}" -gt 0 ]; then
		for hook in ${HOOKS[@]}; do
			[ "$(echo ${DONEHOOK[@]} | tr ' ' '\n' | grep -x $hook)" = "$hook" ] && continue
			if [ -f "$HOOKDIRS"/$hook.hook ]; then
				hookfullpath="$HOOKDIRS"/$hook.hook
			elif [ -f "$HOOKDIRSDATA"/$hook.hook ]; then
				hookfullpath="$HOOKDIRSDATA"/$hook.hook
			else
				msgwarn "missing hook: $hook"
				continue
			fi
			source "$hookfullpath"
			if [ "$(type -t build_hook)" = "function" ]; then
				msg "running build_hook: $hook"
				build_hook
			fi
			echo $hook >> $INITDIR/hook/hook.order
			install -m755 "$hookfullpath" $INITDIR/hook/$hook
			DONEHOOK+=($hook)
			unset hookfullpath build_hook hook
		done
	fi
}

msg() {
	[ $QUIET ] && return
	echo ":: $@"
}

msgerr() {
	[ $QUIET ] && return
	echo "ERROR: $@"
}

msgwarn() {
	[ $QUIET ] && return
	echo "WARNING: $@"
}

cleanup() {
	rm -fr $INITDIR
}

interrupted() {
	cleanup
	exit 1
}

usage() {	
	cat << EOF
Usage:
  $(basename $0) [option] [argument]
  
Options:
  -k <version>  custom kernel version (default: $KERNEL_VERSION)
  -o <output>   custom output name (default: $INITRAMFS)
  -i <init>     custom init file (default: $INITIN)
  -m <modules>  add extra modules (comma separated)
  -b <binaries  add extra binary (comma separated)
  -f <file>     add extra file (comma separated & absolute path)
  -c <config>   use custom config (default: $CONFIG)
  -A <hook>     add extra hook (comma separated, precedence over -a, -s & HOOKS)
  -a <hook>     add extra hook (comma separated, precedence over -s & after HOOKS)
  -s <hook>     skip hook defined in HOOKS
  -q            quiet mode
  -h            print this help msg
	
EOF
}

needarg() {
	if [ ! "$1" ]; then
		echo "ERROR: argument is needed for this option!"
		exit 1
	fi
}		

parse_opt() {
	while [ $1 ]; do
		case $1 in
			-k)	needarg $2
				KERNEL=$2
				shift 1 ;;
			-o)	needarg $2
				OUTPUT=$2
				shift 1 ;;
			-i)	needarg $2
				INIT=$2
				shift 1 ;;
			-c)	needarg $2
				CUSTCONFIG=$2
				shift 1 ;;
			-A)	needarg $2
			    IFS=, read -r -a ADDEARLYHOOKS <<< $2
				shift 1 ;;
			-a)	needarg $2
			    IFS=, read -r -a ADDHOOKS <<< $2
				shift 1 ;;
			-s)	needarg $2
			    IFS=, read -r -a SKIPHOOKS <<< $2
				shift 1 ;;
			-m) needarg $2
			    IFS=, read -r -a ADDMODULES <<< $2
				shift 1 ;;
			-b) needarg $2
			    IFS=, read -r -a ADDBINARIES <<< $2
				shift 1 ;;
			-f) needarg $2
			    IFS=, read -r -a ADDFILES <<< $2
				shift 1 ;;
			-q)	QUIET=1 ;;
			-h)	usage; exit 0 ;;
			*)	echo "ERROR: invalid option '$1'"
				exit 1 ;;
		esac
		shift
	done
}

main() {
	parse_opt $@

	if [ "$UID" != "0" ]; then
		msgerr "need root access!"
		exit 1
	fi
	
	if [ ! $(type -p bsdcpio) ]; then
		msgerr "'bsdcpio' not found, please install 'libarchive' package."
		exit 1
	fi
	
	if [ -f "$CONFIG" ]; then
		. "$CONFIG"
	fi
	
	if [ "$CUSTCONFIG" ]; then
		if [ -f "$CUSTCONFIG" ]; then
			. $CUSTCONFIG
		else
			msgerr "config file '$CUSTCONFIG' not exist."
			exit 1
		fi
	fi
	
	if [ "$KERNEL" ]; then
		if [ -d /lib/modules/"$KERNEL" ]; then
			KERNEL_VERSION="$KERNEL"
		else
			msgerr "kernel directory '/lib/modules/$KERNEL' not exist."
			exit 1
		fi
	else
		if [ ! -d /lib/modules/"$KERNEL_VERSION" ]; then
			NOKMOD=1
		fi
	fi
	
	if [ "$INIT" ]; then
		if [ -f "$INIT" ]; then
			INITIN="$INIT"
		else
			msgerr "init file '$INIT' not exist."
			exit 1
		fi
	fi
	
	if [ "$OUTPUT" ]; then
		if [ $(basename $OUTPUT) != "$OUTPUT" ] && [ ! -d $(dirname $OUTPUT) ]; then
			msgerr "directory '$(dirname $OUTPUT)' for output '$(basename $OUTPUT)' not exist."
			exit 1
		fi
		INITRAMFS="$OUTPUT"
	fi
	
	# filter out skip hooks (-s)
	if [ "${#SKIPHOOKS[@]}" -gt 0 ] && [ "${#HOOKS[@]}" -gt 0 ]; then
		for s in ${!SKIPHOOKS[@]}; do
			for h in ${!HOOKS[@]}; do
				if [ "${SKIPHOOKS[s]}" = "${HOOKS[h]}" ]; then
					unset 'HOOKS[h]'
					break
				fi
			done
		done
	fi
	
	# add extra hooks (-a)
	if [ "${#ADDHOOKS[@]}" -gt 0 ]; then
		HOOKS+=(${ADDHOOKS[@]})
	fi
	
	# add extra early hooks (-A)
	if [ "${#ADDEARLYHOOKS[@]}" -gt 0 ]; then
		ADDEARLYHOOKS+=(${HOOKS[@]})
		HOOKS=(${ADDEARLYHOOKS[@]})
	fi
	
	# add extra modules (-m)
	if [ "${#ADDMODULES[@]}" -gt 0 ]; then
		MODULES+=(${ADDMODULES[@]})
	fi
	
	# add extra files (-f)
	if [ "${#ADDFILES[@]}" -gt 0 ]; then
		FILES+=(${ADDFILES[@]})
	fi
	
	# add extra binary (-b)
	if [ "${#ADDBINARIES[@]}" -gt 0 ]; then
		BINARIES+=(${ADDBINARIES[@]})
	fi

	[ $QUIET ] || echo "Generating initramfs..."
	
	mkdir -p $INITDIR/{hook,newroot}
	install -m0755 $INITIN $INITDIR/init
	run_build_hook
	
	if [ "${#BINARIES[@]}" -gt 0 ]; then
		msg "adding extra binaries..."
		for b in ${BINARIES[@]}; do
			add_binary "$b"
		done
	fi
	
	if [ "${#MODULES[@]}" -gt 0 ]; then
		msg "adding extra modules..."
		for m in ${MODULES[@]}; do
			add_module "$m"
		done
	fi
	
	if [ "${#FILES[@]}" -gt 0 ]; then
		msg "adding extra files..."
		for f in ${FILES[@]}; do
			add_file "$f"
		done
	fi
	
	finalize_modules

	msg "generating initramfs..."
	rm -f "$INITRAMFS"
	( cd $INITDIR ; find . | LANG=C bsdcpio -o -H newc --quiet | gzip -9 ) > $INITRAMFS

	cleanup
	[ $QUIET ] || echo "Generating initramfs done: $INITRAMFS ($(du -h $INITRAMFS | awk '{print $1}'))"
	
	exit 0
}

trap "interrupted" SIGHUP SIGINT SIGQUIT SIGTERM

INITDIR="/tmp/mkinitramfs.$$"
KERNEL_VERSION="$(uname -r)"
INITIN="/usr/share/mkinitramfs/init.in"
INITRAMFS="initrd-$KERNEL_VERSION.img"
CONFIG="/etc/mkinitramfs.conf"
HOOKDIRS="/etc/mkinitramfs.d"
HOOKDIRSDATA="/usr/share/mkinitramfs/hooks"

main $@
